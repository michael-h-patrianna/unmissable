import SwiftUI
import XCTest

@testable import Unmissable

@MainActor
class MeetingDetailsUIAutomationTests: XCTestCase {

  var appState: AppState!

  override func setUp() async throws {
    try await super.setUp()
    appState = AppState()
  }

  override func tearDown() async throws {
    appState = nil
    try await super.tearDown()
  }

  // MARK: - UI Automation Tests

  func testMenuBarEventClickTriggersPopup() async throws {
    // Create sample events for testing
    let sampleEvents = [
      Event(
        id: "ui-test-1",
        title: "UI Test Meeting 1",
        startDate: Date(),
        endDate: Date().addingTimeInterval(1800),
        organizer: "test@example.com",
        description: "This is a test meeting for UI automation.",
        location: "Test Room",
        attendees: [
          Attendee(name: "Test User", email: "test@example.com", status: .accepted)
        ],
        calendarId: "test"
      ),
      Event(
        id: "ui-test-2",
        title: "UI Test Meeting 2",
        startDate: Date().addingTimeInterval(3600),
        endDate: Date().addingTimeInterval(5400),
        description: "Another test meeting with longer description for testing scrollable content. "
          + String(repeating: "This is additional content. ", count: 50),
        attendees: (1...25).map { index in
          Attendee(
            name: "Attendee \(index)", email: "attendee\(index)@example.com", status: .accepted)
        },
        calendarId: "test"
      ),
    ]

    // Test clicking on each event triggers popup
    for event in sampleEvents {
      // Simulate click action from MenuBarView
      appState.showMeetingDetails(for: event)

      // Wait for popup to initialize
      try await Task.sleep(nanoseconds: 200_000_000)  // 0.2 seconds

      // Verify popup behavior (integration test)
      XCTAssertNotNil(appState, "AppState should handle popup display for event: \(event.title)")

      // Wait before next test
      try await Task.sleep(nanoseconds: 100_000_000)  // 0.1 seconds
    }
  }

  func testMenuBarViewUIInteractionEndToEnd() async throws {
    // THIS IS THE REAL UI INTEGRATION TEST
    // Create test events in AppState
    let testEvent = Event(
      id: "integration-test",
      title: "Integration Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      organizer: "integration@example.com",
      description: "This meeting tests the actual UI interaction flow.",
      location: "Integration Room",
      attendees: [
        Attendee(name: "Integration Tester", email: "integration@example.com", status: .accepted)
      ],
      calendarId: "integration"
    )

    // Create MenuBarView instance to validate the environment setup
    _ = MenuBarView()
      .environmentObject(appState)
      .customThemedEnvironment()

    // Test the actual callback that should be triggered by MenuBarView
    // This simulates what happens when user clicks on an event row
    var callbackTriggered = false
    let testCallback: () -> Void = {
      callbackTriggered = true
      self.appState.showMeetingDetails(for: testEvent)
    }

    // Execute the callback to simulate the click
    testCallback()

    // Wait for popup processing
    try await Task.sleep(nanoseconds: 300_000_000)  // 0.3 seconds

    // Validate the core integration worked
    XCTAssertTrue(callbackTriggered, "UI interaction callback should be triggered")
    XCTAssertNotNil(appState, "UI integration should trigger popup successfully")

    // Verify the callback is properly setup (this is the key test)
    XCTAssertGreaterThan(
      appState.upcomingEvents.count, 0, "AppState should have events for testing")
  }

  func testPopupActualVisibilityInUI() async throws {
    // CRITICAL: Test that popup window actually appears in UI
    let testEvent = Event(
      id: "visibility-test",
      title: "Visibility Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      organizer: "visibility@example.com",
      description: "Testing popup visibility in UI",
      attendees: [
        Attendee(name: "Visibility Tester", email: "visibility@example.com", status: .accepted)
      ],
      calendarId: "visibility"
    )

    // Get initial window count
    let initialWindowCount = NSApplication.shared.windows.count

    // Trigger popup display
    appState.showMeetingDetails(for: testEvent)

    // Wait for popup to appear
    try await Task.sleep(nanoseconds: 500_000_000)  // 0.5 seconds

    // Check that a new window was created
    let finalWindowCount = NSApplication.shared.windows.count
    XCTAssertGreaterThan(
      finalWindowCount, initialWindowCount, "A new window should be created for popup")

    // Find the popup window
    let expectedLevel = NSWindow.Level(rawValue: Int(CGWindowLevelForKey(.popUpMenuWindow)) + 1)
    let popupWindows = NSApplication.shared.windows.filter { window in
      // Look for borderless windows with our specific level (above popup menus)
      return window.styleMask.contains(.borderless) && window.level == expectedLevel
        && window.isVisible
    }

    XCTAssertGreaterThan(popupWindows.count, 0, "At least one popup window should be visible")

    // Verify the popup window has content
    if let popupWindow = popupWindows.first {
      XCTAssertNotNil(popupWindow.contentView, "Popup window should have content view")
      XCTAssertTrue(popupWindow.isVisible, "Popup window should be visible")
      XCTAssertTrue(popupWindow.isOnActiveSpace, "Popup window should be on active space")

      // Check window frame is reasonable (not zero size)
      XCTAssertGreaterThan(popupWindow.frame.width, 0, "Popup window should have width")
      XCTAssertGreaterThan(popupWindow.frame.height, 0, "Popup window should have height")

      // Verify window is positioned on screen
      let screenFrame = NSScreen.main?.frame ?? .zero
      XCTAssertTrue(screenFrame.intersects(popupWindow.frame), "Popup window should be on screen")
    }
  }

  func testPopupWindowProperties() async throws {
    // Test specific window properties that affect visibility
    let testEvent = Event(
      id: "properties-test",
      title: "Properties Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      organizer: "properties@example.com",
      description: "Testing popup window properties",
      calendarId: "properties"
    )

    // Trigger popup
    appState.showMeetingDetails(for: testEvent)

    // Wait for popup
    try await Task.sleep(nanoseconds: 300_000_000)

    // Find our popup window
    let expectedLevel = NSWindow.Level(rawValue: Int(CGWindowLevelForKey(.popUpMenuWindow)) + 1)
    let popupWindows = NSApplication.shared.windows.filter { window in
      return window.styleMask.contains(.borderless) && window.level == expectedLevel
    }

    guard let popupWindow = popupWindows.first else {
      XCTFail("No popup window found")
      return
    }

    // Test critical window properties
    XCTAssertEqual(
      popupWindow.level, expectedLevel, "Window level should be above popup menu level")
    XCTAssertTrue(popupWindow.styleMask.contains(.borderless), "Window should be borderless")
    XCTAssertFalse(popupWindow.isReleasedWhenClosed, "Window should not be released when closed")
    XCTAssertTrue(popupWindow.hasShadow, "Window should have shadow for visibility")
    XCTAssertFalse(popupWindow.isOpaque, "Window should not be opaque for rounded corners")
    XCTAssertTrue(popupWindow.isMovableByWindowBackground, "Window should be movable")

    // Test content view
    XCTAssertNotNil(popupWindow.contentView, "Window should have content view")

    // Debug: Print the actual content view type
    print("DEBUG: Content view type: \(String(describing: type(of: popupWindow.contentView)))")
    print("DEBUG: Content view: \(String(describing: popupWindow.contentView))")

    // Check that content view is an NSHostingView (the type will be generic)
    if let contentView = popupWindow.contentView {
      let isNSHostingView = String(describing: type(of: contentView)).contains("NSHostingView")
      XCTAssertTrue(
        isNSHostingView,
        "Content view should be NSHostingView, got: \(String(describing: type(of: contentView)))")
    } else {
      XCTFail("Content view is nil - this is the root cause of the visibility issue")
    }
  }

  func testPopupWithDifferentContentTypes() async throws {
    // Test various content scenarios
    let testCases = [
      // Case 1: Minimal event
      Event(
        id: "minimal",
        title: "Minimal Meeting",
        startDate: Date(),
        endDate: Date().addingTimeInterval(1800),
        calendarId: "test"
      ),

      // Case 2: Event with only description
      Event(
        id: "description-only",
        title: "Description Only Meeting",
        startDate: Date(),
        endDate: Date().addingTimeInterval(1800),
        description: "This meeting has a description but no attendees.",
        calendarId: "test"
      ),

      // Case 3: Event with only attendees
      Event(
        id: "attendees-only",
        title: "Attendees Only Meeting",
        startDate: Date(),
        endDate: Date().addingTimeInterval(1800),
        attendees: [
          Attendee(name: "John Doe", email: "john@example.com", status: .accepted),
          Attendee(email: "jane@example.com", status: .tentative),
        ],
        calendarId: "test"
      ),

      // Case 4: Event with everything
      Event(
        id: "complete",
        title: "Complete Meeting",
        startDate: Date(),
        endDate: Date().addingTimeInterval(1800),
        organizer: "organizer@example.com",
        description: "Complete meeting with all fields populated.",
        location: "Conference Room A",
        attendees: [
          Attendee(
            name: "Organizer", email: "organizer@example.com", status: .accepted, isOrganizer: true),
          Attendee(name: "Required", email: "required@example.com", status: .accepted),
          Attendee(
            name: "Optional", email: "optional@example.com", status: .tentative, isOptional: true),
        ],
        calendarId: "test",
        links: [URL(string: "https://meet.google.com/test")!]
      ),
    ]

    for testEvent in testCases {
      // Test each scenario
      appState.showMeetingDetails(for: testEvent)

      // Allow time for popup processing
      try await Task.sleep(nanoseconds: 300_000_000)  // 0.3 seconds

      // Validate no crashes or exceptions
      XCTAssertNotNil(appState, "Popup should handle \(testEvent.id) scenario gracefully")
    }
  }

  func testPopupMemoryManagementUnderStress() async throws {
    // Stress test with rapid popup operations
    let stressEvent = Event(
      id: "stress-test",
      title: "Stress Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      description: String(repeating: "Stress test content. ", count: 100),
      attendees: (1...50).map { index in
        Attendee(
          name: "Stress Attendee \(index)", email: "stress\(index)@example.com", status: .accepted)
      },
      calendarId: "stress"
    )

    // Perform 20 rapid show operations
    for iteration in 1...20 {
      appState.showMeetingDetails(for: stressEvent)

      // Short delay to simulate user interaction timing
      try await Task.sleep(nanoseconds: 50_000_000)  // 0.05 seconds

      // Every 5 iterations, add a longer pause
      if iteration % 5 == 0 {
        try await Task.sleep(nanoseconds: 200_000_000)  // 0.2 seconds
      }
    }

    // Final validation
    XCTAssertNotNil(appState, "AppState should survive stress testing")

    // Allow cleanup time
    try await Task.sleep(nanoseconds: 500_000_000)  // 0.5 seconds
  }

  func testPopupDeadlockPrevention() async throws {
    let deadlockTestEvent = Event(
      id: "deadlock-test",
      title: "Deadlock Prevention Test",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      description: "Testing deadlock prevention patterns.",
      calendarId: "deadlock"
    )

    // Test concurrent popup operations
    await withTaskGroup(of: Void.self) { group in
      // Spawn multiple concurrent tasks
      for taskId in 1...5 {
        group.addTask { @MainActor in
          // Each task rapidly shows/hides popups
          for _ in 1...10 {
            self.appState.showMeetingDetails(for: deadlockTestEvent)
            try? await Task.sleep(nanoseconds: 10_000_000)  // 0.01 seconds
          }
        }
      }
    }

    // If we reach here without hanging, deadlock prevention worked
    XCTAssertNotNil(appState, "Deadlock prevention should allow completion")
  }

  func testPopupAccessibilityCompliance() async throws {
    let accessibilityEvent = Event(
      id: "a11y-test",
      title: "Accessibility Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      organizer: "a11y@example.com",
      description: "Testing accessibility compliance for screen readers and keyboard navigation.",
      location: "Accessible Room",
      attendees: [
        Attendee(name: "Screen Reader User", email: "sr@example.com", status: .accepted),
        Attendee(name: "Keyboard User", email: "kb@example.com", status: .tentative),
      ],
      calendarId: "a11y"
    )

    // Test popup creation with accessibility considerations
    appState.showMeetingDetails(for: accessibilityEvent)

    // Allow time for accessibility elements to initialize
    try await Task.sleep(nanoseconds: 300_000_000)  // 0.3 seconds

    // Basic validation that popup handles accessibility scenario
    XCTAssertNotNil(appState, "Popup should support accessibility requirements")
  }

  func testPopupThemeResponsiveness() async throws {
    let themeEvent = Event(
      id: "theme-test",
      title: "Theme Test Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      description: "Testing theme responsiveness in popup display.",
      calendarId: "theme"
    )

    // Test popup with different theme scenarios
    let themeTestCases = ["light", "dark", "auto"]

    for theme in themeTestCases {
      // Show popup (theme switching would happen at app level)
      appState.showMeetingDetails(for: themeEvent)

      // Allow time for theme application
      try await Task.sleep(nanoseconds: 100_000_000)  // 0.1 seconds

      // Validate popup works with theme
      XCTAssertNotNil(appState, "Popup should work with \(theme) theme")
    }
  }

  func testPopupWithLargeDatasets() async throws {
    // Test with very large datasets
    let largeEvent = Event(
      id: "large-data",
      title: "Large Dataset Meeting",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      description: String(
        repeating:
          "This is a very long description with lots of content that should test the scrolling behavior and performance of the popup display system. ",
        count: 200),
      attendees: (1...500).map { index in
        Attendee(
          name: "Large Dataset Attendee \(index) with Very Long Name That Tests Layout",
          email:
            "very.long.email.address.for.attendee.number.\(index)@verylongdomainname.example.com",
          status: AttendeeStatus.allCases.randomElement()!,
          isOptional: index % 3 == 0
        )
      },
      calendarId: "large"
    )

    let startTime = CFAbsoluteTimeGetCurrent()

    // Test popup with large dataset
    appState.showMeetingDetails(for: largeEvent)

    // Allow time for rendering
    try await Task.sleep(nanoseconds: 1_000_000_000)  // 1 second

    let endTime = CFAbsoluteTimeGetCurrent()
    let duration = endTime - startTime

    // Performance validation
    XCTAssertLessThan(duration, 2.0, "Large dataset popup should render within 2 seconds")
    XCTAssertNotNil(appState, "Popup should handle large datasets")
  }

  func testPopupErrorHandling() async throws {
    // Test various error scenarios
    let errorCases = [
      // Malformed event data
      Event(
        id: "",  // Empty ID
        title: String(repeating: "🎉", count: 10000),  // Very long title with emojis
        startDate: Date.distantPast,
        endDate: Date.distantFuture,
        organizer: "not-an-email",  // Invalid email
        description: nil,
        location: "",
        attendees: [],
        calendarId: "error"
      )
    ]

    for errorEvent in errorCases {
      // Should handle errors gracefully
      appState.showMeetingDetails(for: errorEvent)

      // Allow processing time
      try await Task.sleep(nanoseconds: 200_000_000)  // 0.2 seconds

      // Should not crash
      XCTAssertNotNil(appState, "Error handling should prevent crashes")
    }
  }

  // MARK: - Production Environment Tests

  func testPopupInProductionEnvironment() async throws {
    // Simulate production environment conditions
    let productionEvent = Event(
      id: "production-test",
      title: "Production Environment Test",
      startDate: Date(),
      endDate: Date().addingTimeInterval(1800),
      description: "Testing popup behavior in production-like conditions.",
      attendees: [
        Attendee(name: "Production User", email: "prod@example.com", status: .accepted)
      ],
      calendarId: "production"
    )

    // Test in production-like environment
    appState.showMeetingDetails(for: productionEvent)

    // Extended wait to simulate real-world conditions
    try await Task.sleep(nanoseconds: 1_000_000_000)  // 1 second

    // Validate production behavior
    XCTAssertNotNil(appState, "Popup should work correctly in production environment")
  }
}
